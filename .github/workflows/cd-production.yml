name: CD - Deploy to Production

on:
  pull_request:
    types:
      - closed
    branches:
      - main

jobs:
  deploy_to_production:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    environment: Production
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Kubernetes context
        run: |
          az aks get-credentials --resource-group ${{ secrets.AZURE_RG }} --name ${{ secrets.AKS_CLUSTER_NAME }} --overwrite-existing

      - name: Verify production namespace exists
        run: |
          if ! kubectl get namespace production &> /dev/null; then
            echo "Creating production namespace..."
            kubectl create namespace production
            kubectl label namespace production environment=production
          else
            echo "Production namespace already exists"
          fi

      - name: Create ConfigMap and Secrets
        run: |
          # Create ConfigMap
          kubectl create configmap ecomm-config-w08e1 \
            --from-literal=PRODUCTS_DB_NAME=productsdb \
            --from-literal=ORDERS_DB_NAME=ordersdb \
            --from-literal=PRODUCT_SERVICE_URL=http://product-service-w08e1:8000 \
            --from-literal=AZURE_STORAGE_CONTAINER_NAME=products \
            --from-literal=AZURE_SAS_TOKEN_EXPIRY_HOURS=24 \
            -n production \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Create Secrets
          kubectl create secret generic ecomm-secrets-w08e1 \
            --from-literal=POSTGRES_USER=postgres \
            --from-literal=POSTGRES_PASSWORD=postgres \
            --from-literal=AZURE_STORAGE_ACCOUNT_NAME=stor224096074 \
            --from-literal=AZURE_STORAGE_ACCOUNT_KEY='${{ secrets.AZURE_STORAGE_KEY }}' \
            -n production \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Wait for resources to be ready
          echo "Waiting for ConfigMap and Secrets to be available..."
          sleep 5

      - name: Deploy Backend Infrastructure to Production
        run: |
          echo "Deploying databases to production..."
          cd k8s/
          kubectl apply -f product-db.yaml -n production
          kubectl apply -f order-db.yaml -n production
          
          echo "Waiting for databases to be ready..."
          kubectl wait --for=condition=ready pod -l app=product-db -n production --timeout=300s || true
          kubectl wait --for=condition=ready pod -l app=order-db -n production --timeout=300s || true

      - name: Deploy Product Service to Production
        run: |
          echo "Deploying Product Service to production..."
          cd k8s/
          cat product-service.yaml | \
            sed "s|image:.*product_service.*|image: ${{ secrets.ACR_LOGIN_SERVER }}/product_service:latest|g" | \
            kubectl apply -f - -n production
          
          kubectl rollout status deployment -l app=product-service -n production --timeout=300s

      - name: Deploy Order Service to Production
        run: |
          echo "Deploying Order Service to production..."
          cd k8s/
          cat order-service.yaml | \
            sed "s|image:.*order_service.*|image: ${{ secrets.ACR_LOGIN_SERVER }}/order_service:latest|g" | \
            kubectl apply -f - -n production
          
          kubectl rollout status deployment -l app=order-service -n production --timeout=300s

      - name: Wait for Production LoadBalancer IPs
        run: |
          echo "Waiting for LoadBalancer IPs..."
          PRODUCT_IP=""
          ORDER_IP=""
          
          for i in $(seq 1 60); do
            echo "Attempt $i/60 to get IPs..."
            PRODUCT_IP=$(kubectl get svc -l app=product-service -n production -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            ORDER_IP=$(kubectl get svc -l app=order-service -n production -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
            if [[ -n "$PRODUCT_IP" && "$PRODUCT_IP" != "null" && -n "$ORDER_IP" && "$ORDER_IP" != "null" ]]; then
              echo "All LoadBalancer IPs assigned!"
              echo "Product Service: http://$PRODUCT_IP:8000"
              echo "Order Service: http://$ORDER_IP:8001"
              break
            fi
            sleep 10
          done

      - name: Verify Production Deployment
        run: |
          echo "=== Production Environment Status ==="
          kubectl get all -n production
          
          # Basic health checks
          PRODUCT_IP=$(kubectl get svc -l app=product-service -n production -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          ORDER_IP=$(kubectl get svc -l app=order-service -n production -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          if [[ -n "$PRODUCT_IP" && "$PRODUCT_IP" != "null" ]]; then
            echo "Testing Product Service health..."
            curl -f http://$PRODUCT_IP:8000/health || echo "Health check pending..."
          fi
          
          if [[ -n "$ORDER_IP" && "$ORDER_IP" != "null" ]]; then
            echo "Testing Order Service health..."
            curl -f http://$ORDER_IP:8001/health || echo "Health check pending..."
          fi
          
          echo "=== Production deployment complete ==="

      - name: Display Production Details
        if: always()
        run: |
          echo "=== Final Production Status ==="
          echo "Namespace: production"
          echo "Deployment Time: $(date)"
          echo "PR Merged: #${{ github.event.pull_request.number }}"
          kubectl get all -n production

      - name: Logout from Azure
        run: az logout
        if: always()