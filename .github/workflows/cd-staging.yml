name: CD - Deploy to Staging

on:
  workflow_run:
    workflows: ["CI - Test, Build and Push Images to ACR"]
    types:
      - completed
    branches:
      - testing

env:
  STAGING_NAMESPACE: staging-${{ github.sha }}

jobs:
  deploy_to_staging:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Kubernetes context
        run: |
          az aks get-credentials --resource-group ${{ secrets.AZURE_RG }} --name ${{ secrets.AKS_CLUSTER_NAME }} --overwrite-existing

      - name: Create staging namespace
        run: |
          kubectl create namespace ${{ env.STAGING_NAMESPACE }} || true
          kubectl label namespace ${{ env.STAGING_NAMESPACE }} environment=staging

      - name: Create ConfigMap and Secrets
        run: |
          # Create ConfigMap
          kubectl create configmap ecomm-config-w08e1 \
            --from-literal=PRODUCTS_DB_NAME=productsdb \
            --from-literal=ORDERS_DB_NAME=ordersdb \
            --from-literal=PRODUCT_SERVICE_URL=http://product-service-w08e1:8000 \
            --from-literal=AZURE_STORAGE_CONTAINER_NAME=products \
            --from-literal=AZURE_SAS_TOKEN_EXPIRY_HOURS=24 \
            -n ${{ env.STAGING_NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Create Secrets
          kubectl create secret generic ecomm-secrets-w08e1 \
            --from-literal=POSTGRES_USER=postgres \
            --from-literal=POSTGRES_PASSWORD=postgres \
            --from-literal=AZURE_STORAGE_ACCOUNT_NAME=stor224096074 \
            --from-literal=AZURE_STORAGE_ACCOUNT_KEY='${{ secrets.AZURE_STORAGE_KEY }}' \
            -n ${{ env.STAGING_NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Wait for resources to be ready
          echo "Waiting for ConfigMap and Secrets to be available..."
          sleep 5

      - name: Deploy Backend Infrastructure to Staging
        run: |
          echo "Deploying databases to staging namespace..."
          cd k8s/
          kubectl apply -f product-db.yaml -n ${{ env.STAGING_NAMESPACE }}
          kubectl apply -f order-db.yaml -n ${{ env.STAGING_NAMESPACE }}
          
          echo "Waiting for databases to be ready..."
          sleep 30
          kubectl wait --for=condition=ready pod -l app=product-db -n ${{ env.STAGING_NAMESPACE }} --timeout=180s || true
          kubectl wait --for=condition=ready pod -l app=order-db -n ${{ env.STAGING_NAMESPACE }} --timeout=180s || true

      - name: Deploy Product Service to Staging
        run: |
          cd k8s/
          cat product-service.yaml | \
            sed "s|image:.*product_service.*|image: ${{ secrets.ACR_LOGIN_SERVER }}/product_service:${{ github.sha }}|g" | \
            kubectl apply -f - -n ${{ env.STAGING_NAMESPACE }}
          
          kubectl wait --for=condition=available deployment -l app=product-service -n ${{ env.STAGING_NAMESPACE }} --timeout=300s

      - name: Deploy Order Service to Staging
        run: |
          cd k8s/
          cat order-service.yaml | \
            sed "s|image:.*order_service.*|image: ${{ secrets.ACR_LOGIN_SERVER }}/order_service:${{ github.sha }}|g" | \
            kubectl apply -f - -n ${{ env.STAGING_NAMESPACE }}
          
          kubectl wait --for=condition=available deployment -l app=order-service -n ${{ env.STAGING_NAMESPACE }} --timeout=300s

      - name: Run Acceptance Tests
        run: |
          echo "=== Running Acceptance Tests in Staging ==="
          
          # Wait for LoadBalancer IPs
          PRODUCT_IP=""
          ORDER_IP=""
          
          for i in $(seq 1 60); do
            echo "Attempt $i/60 to get LoadBalancer IPs..."
            PRODUCT_IP=$(kubectl get svc -l app=product-service -n ${{ env.STAGING_NAMESPACE }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            ORDER_IP=$(kubectl get svc -l app=order-service -n ${{ env.STAGING_NAMESPACE }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
            if [[ -n "$PRODUCT_IP" && "$PRODUCT_IP" != "null" && -n "$ORDER_IP" && "$ORDER_IP" != "null" ]]; then
              echo "LoadBalancer IPs assigned!"
              echo "Product Service: http://$PRODUCT_IP:8000"
              echo "Order Service: http://$ORDER_IP:8001"
              break
            fi
            sleep 10
          done
          
          # Test health endpoints
          if [[ -n "$PRODUCT_IP" && "$PRODUCT_IP" != "null" ]]; then
            echo "Testing Product Service health..."
            curl -f http://$PRODUCT_IP:8000/health || echo "Product service health check pending..."
          fi
          
          if [[ -n "$ORDER_IP" && "$ORDER_IP" != "null" ]]; then
            echo "Testing Order Service health..."
            curl -f http://$ORDER_IP:8001/health || echo "Order service health check pending..."
          fi
          
          echo "=== Acceptance tests completed ==="

      - name: Display Staging Environment Details
        run: |
          echo "=== Staging Environment ==="
          echo "Namespace: ${{ env.STAGING_NAMESPACE }}"
          echo "Commit SHA: ${{ github.sha }}"
          kubectl get all -n ${{ env.STAGING_NAMESPACE }}

      - name: Cleanup Staging Environment
        if: always()
        run: |
          echo "Waiting 30 seconds before cleanup for debugging..."
          sleep 30
          echo "Destroying staging namespace..."
          kubectl delete namespace ${{ env.STAGING_NAMESPACE }} --wait=false || true
          echo "Staging environment cleanup initiated"

      - name: Logout from Azure
        run: az logout
        if: always()